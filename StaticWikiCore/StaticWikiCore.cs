using Markdig;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace StaticWiki
{
    public class StaticWikiCore
    {
        #region Filename Constants
        private const string navigationName = "Navigation.list";
        private const string navigationNameMarkdown = "Navigation.md";
        private const string sourceFilesExtension = "md";
        #endregion

        #region Theme Key Constants
        private const string titleThemeTag = "{TITLE}";
        private const string searchNamesThemeTag = "{SEARCHNAMES}";
        private const string searchURLsThemeTag = "{SEARCHURLS}";
        private const string beginNavigationThemeTag = "{BEGINNAV}";
        private const string endNavigationThemeTag = "{ENDNAV}";
        private const string navigationNameThemeTag = "{NAVNAME}";
        private const string navigationLinkThemeTag = "{NAVLINK}";
        private const string contentThemeTag = "{CONTENT}";
        private const string rootDirectoryThemeTag = "{ROOT}";
        private const string beginPageCategoriesThemeTag = "{BEGINPAGECATEGORIES}";
        private const string endPageCategoriesThemeTag = "{ENDPAGECATEGORIES}";
        private const string beginCategoryPageThemeTag = "{BEGINCATEGORYLIST}";
        private const string endCategoryPageThemeTag = "{ENDCATEGORYLIST}";
        private const string categoryNameThemeTag = "{CATEGORYNAME}";
        private const string categoryLinkThemeTag = "{CATEGORYLINK}";
        private const string beginIfCategoriesThemeTag = "{BEGINIFCATEGORIES}";
        private const string endIfCategoriesThemeTag = "{ENDIFCATEGORIES}";
        private const string baseNameThemeTag = "{BASENAME}";
        private const string pageTitleThemeTag = "{PAGETITLE}";
        private const string templateIndexTag = "{TEMPLATEINDEX}";
        private const string templateItemIndexTag = "{TEMPLATEITEMINDEX}";
        private const string templateItemContentTag = "{TEMPLATEITEMCONTENT}";
        private const string tocTag = "{TOC}";
        #endregion

        #region Misc Constants
        private const string categoryPrefix = "Category:";
        private const string categoryListBaseName = "CategoryList";
        #endregion

        #region Configuration Constants
        private const string configurationFileName = "staticwiki.ini";
        private const string configurationSectionName = "General";
        private const string configurationSourceDirectoryName = "SourceDir";
        private const string configurationOutputDirectoryName = "OutputDir";
        private const string configurationTitleName = "Title";
        private const string configurationDefaultThemeName = "DefaultThemeName";
        private const string configurationThemes = "Themes";
        private const string configurationContentExtensionsName = "ContentExtensions";
        private const string configurationDisableAutoPageExtensionsName = "DisableAutoPageExtensions";
        private const string configurationDisableLinkCorrectionName = "DisableLinkCorrection";
        private const string configurationMarkdownExtensionsName = "MarkdownExtensions";
        #endregion

        /// <summary>
        /// Contains details on a wiki page file
        /// </summary>
        private class FileInfo
        {
            /// <summary>
            /// The page's title
            /// </summary>
            public string pageTitle;

            /// <summary>
            /// The name of this page
            /// </summary>
            public string baseName;

            /// <summary>
            /// The name of this page formatted into a file name
            /// </summary>
            public string saneBaseName;

            /// <summary>
            /// The text of this page
            /// </summary>
            public string text;

            /// <summary>
            /// The theme for this page
            /// </summary>
            public string theme;
        }

        /// <summary>
        /// Strips a Markdown string by removing fake whitespace ("_") and removing Paragraph (<p>) tags
        /// </summary>
        /// <param name="markdownString">The string to strip</param>
        /// <param name="pipeline">The markdown pipeline to use</param>
        /// <returns>The stripped string</returns>
        private static string MarkdownStrippedString(string markdownString, MarkdownPipeline pipeline)
        {
            var outString = Markdown.ToHtml(markdownString.Replace("_", " "), pipeline).Replace("<p>", "").Replace("</p>", "");

            if(outString.Last() == '\n') //Remove the added newline if required
            {
                outString = outString.TrimEnd('\r', '\n');
            }

            return outString;
        }

        /// <summary>
        /// Formats a category name into an proper search name by prefixing it with the category prefix and replacing directory separations into "_"
        /// </summary>
        /// <param name="categoryName">The name of the category</param>
        /// <returns>The formatted category name</returns>
        private static string FormattedCategoryName(string categoryName)
        {
            return string.Format("{0}{1}", categoryPrefix, categoryName.Replace("\\", "/").Replace("/", "_").Replace(" ", "_"));
        }

        /// <summary>
        /// Sanitizes a file name by replacing invalid characters with "_"'s
        /// </summary>
        /// <param name="fileName">The file name</param>
        /// <returns>The sane file name</returns>
        private static string SaneFileName(string fileName)
        {
            string invalidCharacters = Regex.Escape(new string(Path.GetInvalidFileNameChars().Where(x => x != '/' && x != '\\').ToArray()));

            //MacOS allows ":", but this messes things up with categories. Force it to be turned into a "_" for consistency sakes
            if(!invalidCharacters.Contains(":")) {
                invalidCharacters += ":";
            }

            string invalidRegexString = string.Format(@"([{0}]*\.+$)|([{0}]+)", invalidCharacters);

            return Regex.Replace(fileName, invalidRegexString, "_");
        }

        /// <summary>
        /// Handles the Title tag for the current output text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="processedTitle">The title we are to use</param>
        private static void HandleTitleTag(ref string finalText, string processedTitle)
        {
            var index = finalText.IndexOf(titleThemeTag);

            while (index != -1)
            {
                finalText = finalText.Substring(0, index) + processedTitle + finalText.Substring(index + titleThemeTag.Length);

                index = finalText.IndexOf(titleThemeTag);
            }
        }

        /// <summary>
        /// Handles the Page Title tag for the current output text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="processedTitle">The title we are to use</param>
        private static void HandlePageTitleTag(ref string finalText, string processedTitle)
        {
            var index = finalText.IndexOf(pageTitleThemeTag);

            while (index != -1)
            {
                finalText = finalText.Substring(0, index) + processedTitle + finalText.Substring(index + pageTitleThemeTag.Length);

                index = finalText.IndexOf(pageTitleThemeTag);
            }
        }

        /// <summary>
        /// Handles the Search tags for the current output text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="searchNames">The names of the search pages as a single string</param>
        /// <param name="searchURLs">The URLs of the search pages as a single string</param>
        private static void HandleSearchTags(ref string finalText, string searchNames, string searchURLs)
        {
            var index = finalText.IndexOf(searchNamesThemeTag);

            while (index != -1)
            {
                finalText = finalText.Substring(0, index) + searchNames + finalText.Substring(index + searchNamesThemeTag.Length);

                index = finalText.IndexOf(searchNamesThemeTag);
            }

            index = finalText.IndexOf(searchURLsThemeTag);

            while (index != -1)
            {
                finalText = finalText.Substring(0, index) + searchURLs + finalText.Substring(index + searchURLsThemeTag.Length);

                index = finalText.IndexOf(searchURLsThemeTag);
            }
        }

        /// <summary>
        /// Handles navigation details for the navigation bar for the current output text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="navigationInfo">The navigation details using a list of Key Value Pairs where the Key is the Name and the Value is the URL</param>
        /// <param name="navigationContent">The Markdown navigation content (if available) or an empty string</param>
        /// <param name="pipeline">The markdown pipeline we're using (if we're using Markdown navigation)</param>
        private static void HandleNavTags(ref string finalText, List<KeyValuePair<string, string>> navigationInfo, string navigationContent, MarkdownPipeline pipeline)
        {
            var beginNavIndex = -1;
            var endNavIndex = -1;

            var index = finalText.IndexOf(beginNavigationThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + beginNavigationThemeTag.Length);
            beginNavIndex = index;

            index = finalText.IndexOf(endNavigationThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + endNavigationThemeTag.Length);
            endNavIndex = index;

            if (beginNavIndex != -1)
            {
                var clonedText = finalText.Substring(beginNavIndex, endNavIndex - beginNavIndex);
                var processedText = new StringBuilder(finalText.Substring(0, beginNavIndex));

                if(navigationContent != null && navigationContent.Length > 0)
                {
                    processedText.Append(navigationContent);
                }
                else
                {
                    for (var j = 0; j < navigationInfo.Count; j++)
                    {
                        var name = navigationInfo[j].Key;
                        var link = navigationInfo[j].Value.Contains("://") ? navigationInfo[j].Value : SaneFileName(navigationInfo[j].Value);

                        var navItemText = clonedText.Replace(navigationNameThemeTag, name).Replace(navigationLinkThemeTag, link);

                        processedText.Append(navItemText);
                    }
                }

                processedText.Append(finalText.Substring(endNavIndex));

                finalText = processedText.ToString();
            }
        }

        private static void GatherTemplates(ref string finalText, Dictionary<string, string> themeTemplates)
        {
            var templateRegex = new Regex("(?sm)\\[template name=\\\"(.*?)\\\"\\](.*?)\\[\\/template\\]", RegexOptions.Multiline);
            var templateItemRegex = new Regex("(?sm)\\[templateitem\\](.*?)\\[\\/templateitem\\]", RegexOptions.Multiline);
            var templateTagRegex = new Regex("\\[templatetag\\](.*?)\\[\\/templatetag\\]");
            var templateItemTagRegex = new Regex("\\[templateitemtag\\](.*?)\\[\\/templateitemtag\\]");

            foreach (Match templateMatch in templateRegex.Matches(finalText))
            {
                if(templateMatch.Groups.Count == 3)
                {
                    var templateName = templateMatch.Groups[1].Value;
                    var templateContent = templateMatch.Groups[2].Value;

                    if(!themeTemplates.ContainsKey(templateName))
                    {
                        themeTemplates.Add(templateName, templateContent);
                    }
                }

                finalText = finalText.Replace(templateMatch.Groups[0].Value, "");
            }
        }

        /// <summary>
        /// Handles the Content tag for the current output text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="contentText">Our content text</param>
        private static void HandleContentTag(ref string finalText, string contentText)
        {
            var index = finalText.IndexOf(contentThemeTag);

            if (index != -1)
            {
                finalText = finalText.Substring(0, index) + contentText + finalText.Substring(index + contentThemeTag.Length);
            }
        }

        /// <summary>
        /// Handles the tags for a category page
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="baseName">The name of this page</param>
        /// <param name="categoriesInfo">The details of the pages in this category, stored as a Key Value Pair, where the Key is the name and the Value is the URL</param>
        /// <param name="isCategories">Whether we are actually a category page</param>
        private static void HandleCategoryPageTags(ref string finalText, string baseName, List<KeyValuePair<string, string>> categoriesInfo, bool isCategories)
        {
            var beginCategoryPageIndex = -1;
            var endCategoryPageIndex = -1;

            var index = finalText.IndexOf(beginCategoryPageThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + beginCategoryPageThemeTag.Length);
            beginCategoryPageIndex = index;

            index = finalText.IndexOf(endCategoryPageThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + endCategoryPageThemeTag.Length);
            endCategoryPageIndex = index;

            if(!isCategories)
            {
                finalText = finalText.Substring(0, beginCategoryPageIndex) + finalText.Substring(endCategoryPageIndex);

                return;
            }

            var clonedText = finalText.Substring(beginCategoryPageIndex, endCategoryPageIndex - beginCategoryPageIndex);

            var beginPageCategoriesIndex = -1;
            var endPageCategoriesIndex = -1;

            index = clonedText.IndexOf(beginPageCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            clonedText = clonedText.Substring(0, index) + clonedText.Substring(index + beginPageCategoriesThemeTag.Length);
            beginPageCategoriesIndex = index;

            index = clonedText.IndexOf(endPageCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            clonedText = clonedText.Substring(0, index) + clonedText.Substring(index + endPageCategoriesThemeTag.Length);
            endPageCategoriesIndex = index;

            if (beginPageCategoriesIndex != -1)
            {
                var pageCategoryClonedText = clonedText.Substring(beginPageCategoriesIndex, endPageCategoriesIndex - beginPageCategoriesIndex);
                var processedText = new StringBuilder(clonedText.Substring(0, beginPageCategoriesIndex));

                for (var j = 0; j < categoriesInfo.Count; j++)
                {
                    var name = categoriesInfo[j].Key;
                    var link = SaneFileName(categoriesInfo[j].Value);
                    var categoryItemText = pageCategoryClonedText.Replace(categoryNameThemeTag, name).Replace(categoryLinkThemeTag, link);

                    processedText.Append(categoryItemText);
                }

                processedText.Append(clonedText.Substring(endPageCategoriesIndex));

                clonedText = processedText.ToString();
            }

            finalText = finalText.Substring(0, beginCategoryPageIndex) + clonedText + finalText.Substring(endCategoryPageIndex);
        }

        /// <summary>
        /// Handles the Category tags in a page
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="baseName">The name of this page</param>
        /// <param name="categoriesInfo">The details of the pages in this category, stored as a Key Value Pair, where the Key is the name and the Value is the URL</param>
        /// <param name="isCategories">Whether we are actually a category page</param>
        private static void HandleCategoryTags(ref string finalText, string baseName, List<KeyValuePair<string, string>> categoriesInfo, bool isCategories)
        {
            HandleCategoryPageTags(ref finalText, baseName, categoriesInfo, isCategories);

            var beginIfCategoriesIndex = -1;
            var endIfCategoriesIndex = -1;
            var index = finalText.IndexOf(beginIfCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + beginIfCategoriesThemeTag.Length);

            beginIfCategoriesIndex = index;

            index = finalText.IndexOf(endIfCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            finalText = finalText.Substring(0, index) + finalText.Substring(index + endIfCategoriesThemeTag.Length);
            endIfCategoriesIndex = index;

            //If we have no valid categories, skip the whole thing
            if (isCategories || categoriesInfo.Count == 0)
            {
                finalText = finalText.Substring(0, beginIfCategoriesIndex) + finalText.Substring(endIfCategoriesIndex);

                return;
            }

            var clonedText = finalText.Substring(beginIfCategoriesIndex, endIfCategoriesIndex - beginIfCategoriesIndex);

            var beginPageCategoriesIndex = -1;
            var endPageCategoriesIndex = -1;

            index = clonedText.IndexOf(beginPageCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            clonedText = clonedText.Substring(0, index) + clonedText.Substring(index + beginPageCategoriesThemeTag.Length);
            beginPageCategoriesIndex = index;

            index = clonedText.IndexOf(endPageCategoriesThemeTag);

            if (index == -1)
            {
                return;
            }

            clonedText = clonedText.Substring(0, index) + clonedText.Substring(index + endPageCategoriesThemeTag.Length);
            endPageCategoriesIndex = index;

            if (beginPageCategoriesIndex != -1)
            {
                var pageCategoryClonedText = clonedText.Substring(beginPageCategoriesIndex, endPageCategoriesIndex - beginPageCategoriesIndex);
                var processedText = new StringBuilder(clonedText.Substring(0, beginPageCategoriesIndex));

                for (var j = 0; j < categoriesInfo.Count; j++)
                {
                    var name = categoriesInfo[j].Key;
                    var link = SaneFileName(categoriesInfo[j].Value);
                    var categoryItemText = pageCategoryClonedText.Replace(categoryNameThemeTag, name).Replace(categoryLinkThemeTag, link);

                    processedText.Append(categoryItemText);
                }

                processedText.Append(clonedText.Substring(endPageCategoriesIndex));

                clonedText = processedText.ToString();
            }

            finalText = finalText.Substring(0, beginIfCategoriesIndex) + clonedText + finalText.Substring(endIfCategoriesIndex);
        }

        /// <summary>
        /// Handles the root directory tag from the current finalized text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="currentDirectory">Our current directory</param>
        private static void HandleRootDirectoryTag(ref string finalText, string currentDirectory)
        {
            var index = finalText.IndexOf(rootDirectoryThemeTag);
            var recursiveBack = currentDirectory.Length > 0 ?
                string.Join("", currentDirectory.Replace("\\", "/").Split("/".ToCharArray()).Select(x => "../")) : "";

            while (index != -1)
            {
                finalText = finalText.Substring(0, index) + recursiveBack + finalText.Substring(index + rootDirectoryThemeTag.Length);
                index = finalText.IndexOf(rootDirectoryThemeTag);
            }
        }

        /// <summary>
        /// Handles the user tags from the current finalized text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="userTags">The dictionary to keep our user tags</param>
        private static void HandleUserTags(ref string finalText, Dictionary<string, string> userTags)
        {
            var userTagRegex = new Regex("\\[usertag name=\\\"(.*?)\\\" value=\\\"(.*?)\\\"\\]");

            foreach(Match m in userTagRegex.Matches(finalText))
            {
                if(m.Groups.Count == 3)
                {
                    var name = m.Groups[1].Value;
                    var value = m.Groups[2].Value;

                    if(!userTags.ContainsKey(name))
                    {
                        userTags.Add(name, value);
                    }
                }

                finalText = finalText.Replace(m.Groups[0].Value, "");
            }
        }

        /// <summary>
        /// Processes the templates in a page and applies the loaded theme templates to them
        /// </summary>
        /// <param name="contentText">The content text of the page</param>
        /// <param name="themeTemplates">The available theme templates</param>
        /// <param name="userTags">The available user tags</param>
        private static void HandleTemplates(ref string contentText, Dictionary<string, string> themeTemplates, Dictionary<string, string> userTags)
        {
            var templateRegex = new Regex("(?sm)\\[template name=\\&quot;(.*?)\\&quot;\\](.*?)\\[\\/template\\]", RegexOptions.Multiline);
            var templateTagRegex = new Regex("(?sm)\\[templatetag name=\\&quot;(.*?)\\&quot;\\](.*?)\\[\\/templatetag\\]");
            var templateItemRegex = new Regex("(?sm)\\[templateitem\\](.*?)\\[\\/templateitem\\]", RegexOptions.Multiline);
            var templateItemTagRegex = new Regex("(?sm)\\[templateitemtag name=\\&quot;(.*?)\\&quot;\\](.*?)\\[\\/templateitemtag\\]");
            var themeTemplateTagRegex = new Regex("\\[templatetag\\](.*?)\\[\\/templatetag\\]");
            var themeTemplateItemTagRegex = new Regex("\\[templateitemtag\\](.*?)\\[\\/templateitemtag\\]");
            var templateIndex = 0;

            foreach (Match m in templateRegex.Matches(contentText))
            {
                if (m.Groups.Count == 3)
                {
                    var index = 0;
                    var templateName = m.Groups[1].Value;
                    var templateContent = m.Groups[2].Value;

                    if(!themeTemplates.ContainsKey(templateName))
                    {
                        contentText = contentText.Replace(m.Groups[0].Value, "");

                        continue;
                    }

                    var templateText = themeTemplates[templateName];
                    var templateTags = new Dictionary<string, string>();
                    var templateItemIndex = 0;
                    templateIndex++;

                    foreach (Match templateTagMatch in templateTagRegex.Matches(templateContent))
                    {
                        if(templateTagMatch.Groups.Count == 3)
                        {
                            var name = templateTagMatch.Groups[1].Value;
                            var value = templateTagMatch.Groups[2].Value;

                            if(!templateTags.ContainsKey(name))
                            {
                                templateTags.Add(name, value);
                            }
                        }

                        templateContent = templateContent.Replace(templateTagMatch.Groups[0].Value, "");
                    }

                    var templateProcessedText = (string)templateText.Clone();

                    foreach (Match themeTemplateTagMatch in themeTemplateTagRegex.Matches(templateProcessedText.ToString()))
                    {
                        if (themeTemplateTagMatch.Groups.Count == 2)
                        {
                            var tag = themeTemplateTagMatch.Groups[1].Value;

                            if (templateTags.ContainsKey(tag))
                            {
                                templateProcessedText = templateProcessedText.Replace(themeTemplateTagMatch.Groups[0].Value, templateTags[tag]);
                            }
                            else
                            {
                                templateProcessedText = templateProcessedText.Replace(themeTemplateTagMatch.Groups[0].Value, "");
                            }
                        }
                    }

                    var itemProcessedText = "";

                    Match themeTemplateItemMatch = templateItemRegex.Match(templateProcessedText.ToString());

                    if (themeTemplateItemMatch != null)
                    {
                        if (themeTemplateItemMatch.Groups.Count == 2)
                        {
                            foreach (Match templateItemMatch in templateItemRegex.Matches(templateContent))
                            {
                                if (templateItemMatch.Groups.Count == 2)
                                {
                                    var templateItemTags = new Dictionary<string, string>();
                                    var templateItemContent = templateItemMatch.Groups[1].Value;

                                    foreach (Match templateItemTagMatch in templateItemTagRegex.Matches(templateItemContent))
                                    {
                                        if (templateItemTagMatch.Groups.Count == 3)
                                        {
                                            var name = templateItemTagMatch.Groups[1].Value;
                                            var value = templateItemTagMatch.Groups[2].Value;

                                            if (!templateItemTags.ContainsKey(name))
                                            {
                                                templateItemTags.Add(name, value);
                                            }
                                        }

                                        templateItemContent = templateItemContent.Replace(templateItemTagMatch.Groups[0].Value, "");
                                    }

                                    var itemText = themeTemplateItemMatch.Groups[1].Value;

                                    foreach (Match themeTemplateItemTagMatch in themeTemplateTagRegex.Matches(itemText))
                                    {
                                        if (themeTemplateItemTagMatch.Groups.Count == 2)
                                        {
                                            var tag = themeTemplateItemTagMatch.Groups[1].Value;

                                            if (templateTags.ContainsKey(tag))
                                            {
                                                itemText = itemText.Replace(themeTemplateItemTagMatch.Groups[0].Value, templateTags[tag]);
                                            }
                                            else
                                            {
                                                itemText = itemText.Replace(themeTemplateItemTagMatch.Groups[0].Value, "");
                                            }
                                        }
                                    }

                                    foreach (Match themeTemplateItemTagMatch in themeTemplateItemTagRegex.Matches(itemText))
                                    {
                                        if (themeTemplateItemTagMatch.Groups.Count == 2)
                                        {
                                            var tag = themeTemplateItemTagMatch.Groups[1].Value;

                                            if (templateItemTags.ContainsKey(tag))
                                            {
                                                itemText = itemText.Replace(themeTemplateItemTagMatch.Groups[0].Value, templateItemTags[themeTemplateItemTagMatch.Groups[1].Value]);
                                            }
                                            else
                                            {
                                                itemText = itemText.Replace(themeTemplateItemTagMatch.Groups[0].Value, "");
                                            }
                                        }
                                    }

                                    itemText = itemText.Replace(templateItemIndexTag, templateItemIndex.ToString());
                                    itemText = itemText.Replace(templateItemContentTag, templateItemContent);

                                    templateItemIndex++;

                                    itemProcessedText += itemText;
                                }
                            }

                            templateProcessedText = templateProcessedText.Replace(themeTemplateItemMatch.Groups[0].Value, itemProcessedText);
                        }
                    }

                    templateProcessedText = templateProcessedText.Replace(templateIndexTag, templateIndex.ToString());

                    index = contentText.IndexOf(m.Groups[0].Value);

                    if(index != -1)
                    {
                        contentText = contentText.Substring(0, index) + templateProcessedText + contentText.Substring(index + m.Groups[0].Value.Length);
                    }

                    continue;
                }

                contentText = contentText.Replace(m.Groups[0].Value, "");
            }
        }

        /// <summary>
        /// Handles the TOC Tag from the current content text, extracting it
        /// </summary>
        /// <param name="contentText">The current content text</param>
        /// <param name="tocContent">The TOC Content, if any</param>
        private static void HandleTOCTag(ref string contentText, out string tocContent)
        {
            var regex = new Regex("(?sm)\\[toc\\](.*?)\\[\\/toc\\]", RegexOptions.Multiline);

            var match = regex.Match(contentText);

            if(match != null)
            {
                if(match.Groups.Count == 2)
                {
                    tocContent = match.Groups[1].Value;

                    contentText = contentText.Replace(match.Groups[0].Value, "");

                    return;
                }
            }

            tocContent = "";
        }

        /// <summary>
        /// Handles the basename tag from the current finalized text
        /// </summary>
        /// <param name="finalText">Our current finalized text</param>
        /// <param name="baseName">The base name of the current page</param>
        private static void HandleBasenameTag(ref string finalText, string baseName)
        {
            var index = finalText.IndexOf(baseNameThemeTag);
            var fileName = Path.GetFileName(baseName);

            while(index != -1)
            {
                finalText = finalText.Substring(0, index) + baseName + finalText.Substring(index + baseNameThemeTag.Length);
                index = finalText.IndexOf(baseNameThemeTag);
            }
        }

        /// <summary>
        /// Processes links in content by validating whether they exist and replacing them properly or marking them as invalid
        /// </summary>
        /// <param name="content">The content text</param>
        /// <param name="sourceDirectory">Our current source directory</param>
        /// <param name="currentDirectory">Our current directory</param>
        /// <param name="pageExtension">Our page extension</param>
        /// <param name="searchURLs">Our search URLs</param>
        /// <param name="disableAutoPageExtension">Disables automatically adding page extensions to page links</param>
        /// <param name="disableLinkCorrection">Disables automatically replacing invalid links with "#"</param>
        /// <returns>The processed links</returns>
        private static string HandlePageLinks(string pageName, string content, string sourceDirectory, string currentDirectory, string pageExtension, string[] searchURLs, bool disableAutoPageExtension, bool disableLinkCorrection)
        {
            var linkHrefRegex = new Regex("<a href=\"(.*?)\">((?:.(?!\\<\\/a\\>))*.)<\\/a>");
            var pageLinkRegex = new Regex("\\[pagelink\\](.*?)\\[\\/pagelink\\]");
            var activePageRegex = new Regex("(?sm)\\[activepage name=\\\"(.*?)\\\"\\](.*?)\\[\\/activepage\\]", RegexOptions.Multiline);
            var activePageRegexAlternative = new Regex("(?sm)\\[activepage name=&quot;(.*?)&quot;\\](.*?)\\[\\/activepage\\]", RegexOptions.Multiline);

            foreach (Match linkMatch in linkHrefRegex.Matches(content))
            {
                if (linkMatch.Groups.Count == 3)
                {
                    var urlGroup = linkMatch.Groups[1];
                    var url = urlGroup.Value.Replace("\\", "/");
                    var invalid = false;
                    var filePath = url.Contains("://") ? url : Path.Combine(sourceDirectory, currentDirectory, SaneFileName(url));

                    if (!url.Contains("://") && !Directory.Exists(filePath) && !File.Exists(filePath) && !url.StartsWith("#"))
                    {
                        var recursiveBack = currentDirectory.Length > 0 ?
                            string.Join("", currentDirectory.Replace("\\", "/").Split("/".ToCharArray()).Select(x => "../")) : "";

                        if (searchURLs.Where(x => x.EndsWith(SaneFileName(url))).Any())
                        {
                            url = string.Format("{0}{1}{2}", recursiveBack, SaneFileName(searchURLs.Where(x => x.EndsWith(SaneFileName(url))).FirstOrDefault()), disableAutoPageExtension ? "" : pageExtension);
                        }
                        else
                        {
                            invalid = true;
                        }

                        if (invalid && !disableLinkCorrection)
                        {
                            content = content.Replace(linkMatch.Groups[0].Value, string.Format("<a href=\"#\">{0}</a>", linkMatch.Groups[2].Value));
                        }
                        else
                        {
                            content = content.Replace(linkMatch.Groups[0].Value, string.Format("<a href=\"{0}\">{1}</a>", url, linkMatch.Groups[2].Value));
                        }
                    }
                }
            }

            foreach(Match pageLinkMatch in pageLinkRegex.Matches(content))
            {
                if (pageLinkMatch.Groups.Count == 2)
                {
                    var urlGroup = pageLinkMatch.Groups[1];
                    var url = urlGroup.Value.Replace("\\", "/");
                    var invalid = false;
                    var filePath = Path.Combine(sourceDirectory, currentDirectory, SaneFileName(url));

                    if (!Directory.Exists(filePath) && !File.Exists(filePath))
                    {
                        var recursiveBack = currentDirectory.Length > 0 ?
                            string.Join("", currentDirectory.Replace("\\", "/").Split("/".ToCharArray()).Select(x => "../")) : "";

                        if (searchURLs.Where(x => x.EndsWith(SaneFileName(url))).Any())
                        {
                            url = string.Format("{0}{1}{2}", recursiveBack, SaneFileName(searchURLs.Where(x => x.EndsWith(SaneFileName(url))).FirstOrDefault()), disableAutoPageExtension ? "" : pageExtension);
                        }
                        else
                        {
                            invalid = true;
                        }

                        if (invalid && !disableLinkCorrection)
                        {
                            content = content.Replace(pageLinkMatch.Groups[0].Value, pageLinkMatch.Groups[1].Value);
                        }
                        else
                        {
                            content = content.Replace(pageLinkMatch.Groups[0].Value, url);
                        }
                    }
                }
            }

            foreach(Match activePageMatch in activePageRegex.Matches(content))
            {
                if (activePageMatch.Groups.Count == 3)
                {
                    var activePageName = activePageMatch.Groups[1].Value;
                    var activeContent = activePageMatch.Groups[2].Value;

                    if(pageName.ToLower() == activePageName.ToLower())
                    {
                        content = content.Replace(activePageMatch.Groups[0].Value, activeContent);
                    }
                    else
                    {
                        content = content.Replace(activePageMatch.Groups[0].Value, "");
                    }
                }
            }

            foreach (Match activePageMatch in activePageRegexAlternative.Matches(content))
            {
                if (activePageMatch.Groups.Count == 3)
                {
                    var activePageName = activePageMatch.Groups[1].Value;
                    var activeContent = activePageMatch.Groups[2].Value;

                    if (pageName.ToLower() == activePageName.ToLower())
                    {
                        content = content.Replace(activePageMatch.Groups[0].Value, activeContent);
                    }
                    else
                    {
                        content = content.Replace(activePageMatch.Groups[0].Value, "");
                    }
                }
            }

            return content;
        }

        /// <summary>
        /// Processes the navigation file
        /// </summary>
        /// <param name="content">The file's contents</param>
        /// <returns>The processed navigation data</returns>
        private static List<KeyValuePair<string, string>> ProcessNavigationFileContent(string content, ref string logMessage)
        {
            var outNavigation = new List<KeyValuePair<string, string>>();
            var lines = content.Split("\n".ToCharArray());

            foreach (var line in lines)
            {
                if (line.Length == 0)
                {
                    continue;
                }

                var pieces = line.Split("=".ToCharArray());

                if (pieces.Length < 2)
                {
                    continue;
                }

                var navName = pieces[0].Replace("\n", "").Replace("\r", "").Trim();
                var navLink = string.Join("=", pieces.Skip(1).ToArray()).Replace("\n", "").Replace("\r", "").Trim();

                outNavigation.Add(new KeyValuePair<string, string>(navName, navLink));
            }

            return outNavigation;
        }

        /// <summary>
        /// Processes a page file and returns its processed contents
        /// </summary>
        /// <param name="baseName">The page name</param>
        /// <param name="sourceText">The source text</param>
        /// <param name="themeText">The theme text</param>
        /// <param name="title">The page's title with the wiki title prepended</param>
        /// <param name="pageTitle">The page's title</param>
        /// <param name="navigationInfo">The Navigation Information</param>
        /// <param name="searchNames">The names of all searchable pages</param>
        /// <param name="searchURLs">The URLs of all searchable pages</param>
        /// <param name="categoriesInfo">The Category Information for this page</param>
        /// <param name="sourceDirectory">Our source directory</param>
        /// <param name="currentDirectory">Our currrent directory</param>
        /// <param name="pageExtension">Our page extension</param>
        /// <param name="isCategories">Whether we're a category page</param>
        /// <param name="disableAutoPageExtension">Disables automatically adding page extensions to page links</param>
        /// <param name="disableLinkCorrection">Disables automatically replacing invalid links with "#"</param>
        /// <param name="navigationContent">Content for Markdown navigation (if available) or empty string</param>
        /// <param name="markdownPipeline">The markdown pipeline to use</param>
        /// <returns>The processed page contents</returns>
        public static string ProcessFile(string baseName, string sourceText, string themeText, string title, string pageTitle, List<KeyValuePair<string, string>> navigationInfo,
            string[] searchNames, string[] searchURLs, List<KeyValuePair<string, string>> categoriesInfo, string sourceDirectory, string currentDirectory, string pageExtension,
            bool isCategories, bool disableAutoPageExtension, bool disableLinkCorrection, string navigationContent, MarkdownPipeline markdownPipeline)
        {
            var recursiveBack = currentDirectory.Length > 0 ?
                string.Join("", currentDirectory.Replace("\\", "/").Split("/".ToCharArray()).Select(x => "../")) : "";
            var searchNamesString = string.Join(",", searchNames.Select(x => string.Format("\"{0}\"", MarkdownStrippedString(x, markdownPipeline).Replace("\n", ""))).ToArray());
            var searchURLsString = string.Join(",", searchURLs.Select(x => string.Format("\"{0}{1}{2}\"", recursiveBack, x, pageExtension)).ToArray());
            var contentText = Markdown.ToHtml(sourceText, markdownPipeline);
            var processedTitle = MarkdownStrippedString(title, markdownPipeline);
            var userTags = new Dictionary<string, string>();
            var themeTemplates = new Dictionary<string, string>();
            var finalText = (string)themeText.Clone();
            var tocContent = "";

            if(navigationContent.Length > 0)
            {
                navigationContent = Markdown.ToHtml(navigationContent, markdownPipeline);
            }

            GatherTemplates(ref finalText, themeTemplates);

            HandleTOCTag(ref contentText, out tocContent);

            HandleUserTags(ref navigationContent, userTags);
            HandleTemplates(ref navigationContent, themeTemplates, userTags);

            HandleUserTags(ref contentText, userTags);
            HandleTemplates(ref contentText, themeTemplates, userTags);

            HandleUserTags(ref tocContent, userTags);
            HandleTemplates(ref tocContent, themeTemplates, userTags);

            finalText = finalText.Replace(tocTag, tocContent);

            HandleTitleTag(ref finalText, processedTitle);
            HandlePageTitleTag(ref finalText, pageTitle);
            HandleSearchTags(ref finalText, searchNamesString, searchURLsString);
            HandleNavTags(ref finalText, navigationInfo, navigationContent, markdownPipeline);
            HandleCategoryTags(ref finalText, baseName, categoriesInfo, isCategories);
            HandleBasenameTag(ref finalText, baseName);
            HandleRootDirectoryTag(ref finalText, currentDirectory);
            HandleContentTag(ref finalText, contentText);

            finalText = HandlePageLinks(baseName, finalText, sourceDirectory, currentDirectory,
                pageExtension, searchURLs, disableAutoPageExtension, disableLinkCorrection);

            return finalText;
        }

        /// <summary>
        /// Copies the resources from a theme folder to a destination directory
        /// </summary>
        /// <param name="themeFileName">The theme's file name</param>
        /// <param name="destinationDirectory">Our destination directory</param>
        /// <param name="otherThemeFiles">The list of other theme files</param>
        /// <param name="logMessage">Our current log message</param>
        /// <returns>Whether we successfully copied the files</returns>
        private static bool CopyThemeResourcesToFolder(string themeFileName, string destinationDirectory,
            string[] otherThemeFiles, ref string logMessage)
        {
            var files = new string[0];
            var themeDirectory = Path.GetDirectoryName(themeFileName);
            var lastFile = "";

            try
            {
                files = Directory.GetFiles(themeDirectory, "*.*", SearchOption.AllDirectories);

                foreach (var file in files)
                {
                    if (file == Path.GetFullPath(themeFileName) ||
                        otherThemeFiles.Any(x => x.Replace("\\", "/") == file.Replace("\\", "/")))
                    {
                        continue;
                    }

                    var baseName = file.Substring(themeDirectory.Length + 1);
                    var outName = Path.Combine(destinationDirectory, baseName);

                    logMessage += string.Format("... {0} (as '{1}')\n", file, outName);
                    lastFile = file;

                    var directory = Path.GetDirectoryName(outName);

                    if (!Directory.Exists(directory))
                    {
                        Directory.CreateDirectory(directory);
                    }

                    File.Copy(file, outName, true);
                }
            }
            catch (Exception)
            {
                logMessage += string.Format("StaticWiki failed to copy theme resource '{0}' to '{1}'. Aborting theme resource copying.", lastFile, destinationDirectory);

                return false;
            }

            return true;
        }

        /// <summary>
        /// Deletes a directory
        /// </summary>
        /// <param name="destinationDirectory">The directory to delete</param>
        private static void DeleteDirectory(string destinationDirectory)
        {
            var files = Directory.GetFiles(destinationDirectory);
            var directories = Directory.GetDirectories(destinationDirectory);

            var directoryInfo = new DirectoryInfo(destinationDirectory);
            directoryInfo.Attributes &= ~FileAttributes.ReadOnly;

            foreach (var file in files)
            {
                File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
                File.Delete(file);
            }

            foreach (var directory in directories)
            {
                DeleteDirectory(directory);
            }

            Directory.Delete(destinationDirectory, false);
        }

        /// <summary>
        /// Processes a source directory into a destination directory
        /// </summary>
        /// <param name="sourceDirectory">The source directory</param>
        /// <param name="destinationDirectory">The destination directory</param>
        /// <param name="defaultTheme">The default theme to use</param>
        /// <param name="themes">A list in the form of name->filename of all themes</param>
        /// <param name="navigationFileName">The file name of the navigation file</param>
        /// <param name="contentExtensions">The file extensions for all content files</param>
        /// <param name="baseTitle">The wiki title</param>
        /// <param name="disableAutoPageExtension">Disables automatically adding page extensions to page links</param>
        /// <param name="disableLinkCorrection">Disables automatically replacing invalid links with "#"</param>
        /// <param name="logMessage">Our current log message</param>
        /// <param name="markdownExtensions">Extra markdown extensions to use</param>
        /// <returns>Whether we successfully processed the source into the destination</returns>
        public static bool ProcessDirectory(string sourceDirectory, string destinationDirectory, string defaultTheme,
            KeyValuePair<string, string>[] themes, string navigationFileName, string[] contentExtensions, string baseTitle,
            bool disableAutoPageExtension, bool disableLinkCorrection, string[] markdownExtensions, ref string logMessage)
        {
            var fileCache = new Dictionary<string, FileInfo>();
            var files = new string[0];
            var categoriesDictionary = new Dictionary<string, List<string>>();
            var categoriesRegex = new Regex("\\[categories\\](.*?)\\[\\/categories\\]");
            var titleRegex = new Regex("\\[title\\](.*?)\\[\\/title\\]");
            var themeRegex = new Regex("\\[theme\\](.*?)\\[\\/theme\\]");
            var themesDictionary = new Dictionary<string, string>();

            logMessage = "";

            try
            {
                DeleteDirectory(destinationDirectory);
            }
            catch (Exception e)
            {
                logMessage += string.Format("StaticWiki failed to delete destination directory: '{0}'\n", e.Message);
            }

            try
            {
                files = Directory.GetFiles(sourceDirectory, string.Format("*.{0}", sourceFilesExtension), SearchOption.AllDirectories);
            }
            catch (Exception)
            {
                logMessage += string.Format("StaticWiki failed to find files at the directory '{0}'\n", sourceDirectory);

                return false;
            }

            foreach(var pair in themes)
            {
                try
                {
                    if (!themesDictionary.ContainsKey(pair.Key.ToLowerInvariant()))
                    {
                        var inReader = new StreamReader(pair.Value);

                        var text = inReader.ReadToEnd();

                        themesDictionary.Add(pair.Key.ToLowerInvariant(), text);
                    }
                }
                catch (Exception e)
                {
                    logMessage += string.Format("Failed to read theme file \"{0}\": {1}\n", pair.Key, e.Message);

                    return false;
                }
            }

            if(!themesDictionary.ContainsKey(defaultTheme.ToLowerInvariant()))
            {
                logMessage += string.Format("Default theme \"{0}\" not found among loaded themes", defaultTheme);
            }

            try
            {
                if (!Directory.Exists(destinationDirectory))
                {
                    Directory.CreateDirectory(destinationDirectory);
                }
            }
            catch (Exception)
            {
            }

            foreach(var pair in themes)
            {
                var otherThemeFiles = themes
                    .Where(x => x.Key != pair.Key)
                    .Select(x => x.Value)
                    .ToArray();

                CopyThemeResourcesToFolder(pair.Value, destinationDirectory, otherThemeFiles, ref logMessage);
            }

            var navigationInfo = new List<KeyValuePair<string, string>>();
            var navigationContent = "";

            try
            {
                var content = File.ReadAllText(navigationFileName);

                if(navigationFileName.EndsWith(".md"))
                {
                    logMessage += "Loading navigation from Markdown navigation\n";

                    navigationContent = content;
                }
                else
                {
                    logMessage += "Loading navigation from Navigation List\n";

                    navigationInfo = ProcessNavigationFileContent(content, ref logMessage);
                }
            }
            catch (Exception)
            {
                logMessage += string.Format("Failed to read navigation info from '{0}'\n", navigationFileName);
            }

            var pipelineBuilder = new MarkdownPipelineBuilder();
            var upperExtensions = markdownExtensions.Select(x => x.ToUpper()).ToList();
            var usedExtensions = new List<string>();

            foreach(var extension in upperExtensions)
            {
                if(extension == "Bootstrap".ToUpper())
                {
                    usedExtensions.Add("Bootstrap");
                    pipelineBuilder = pipelineBuilder.UseBootstrap();
                }
                else if(extension == "Pipe Tables".ToUpper())
                {
                    usedExtensions.Add("Pipe Tables");
                    pipelineBuilder = pipelineBuilder.UsePipeTables();
                }
                else if(extension == "Grid Tables".ToUpper())
                {
                    usedExtensions.Add("Grid Tables");
                    pipelineBuilder = pipelineBuilder.UseGridTables();
                }
                else if(extension == "Extra Emphasis".ToUpper())
                {
                    usedExtensions.Add("Extra Emphasis");
                    pipelineBuilder = pipelineBuilder.UseEmphasisExtras();
                }
                else if(extension == "Special Attributes".ToUpper())
                {
                    usedExtensions.Add("Special Attributes");
                    pipelineBuilder = pipelineBuilder.UseGenericAttributes();
                }
                else if (extension == "Definition Lists".ToUpper())
                {
                    usedExtensions.Add("Definition Lists");
                    pipelineBuilder = pipelineBuilder.UseDefinitionLists();
                }
                else if (extension == "Footnotes".ToUpper())
                {
                    usedExtensions.Add("Footnotes");
                    pipelineBuilder = pipelineBuilder.UseFootnotes();
                }
                else if (extension == "Auto Identifiers".ToUpper())
                {
                    Markdig.Extensions.AutoIdentifiers.AutoIdentifierOptions options = 
                        Markdig.Extensions.AutoIdentifiers.AutoIdentifierOptions.AllowOnlyAscii;

                    usedExtensions.Add("Auto Identifiers");
                    pipelineBuilder = pipelineBuilder.UseAutoIdentifiers(options);
                }
                else if (extension == "Auto Links".ToUpper())
                {
                    usedExtensions.Add("Auto Links");
                    pipelineBuilder = pipelineBuilder.UseAutoLinks();
                }
                else if (extension == "Task Lists".ToUpper())
                {
                    usedExtensions.Add("Task Lists");
                    pipelineBuilder = pipelineBuilder.UseTaskLists();
                }
                else if (extension == "Extra Bullet Lists".ToUpper())
                {
                    usedExtensions.Add("Extra Bullet Lists");
                    pipelineBuilder = pipelineBuilder.UseListExtras();
                }
                else if (extension == "Media Support".ToUpper())
                {
                    usedExtensions.Add("Media Support");
                    pipelineBuilder = pipelineBuilder.UseMediaLinks();
                }
                else if (extension == "Abbreviations".ToUpper())
                {
                    usedExtensions.Add("Abbreviations");
                    pipelineBuilder = pipelineBuilder.UseAbbreviations();
                }
                else if (extension == "Citations".ToUpper())
                {
                    usedExtensions.Add("Citations");
                    pipelineBuilder = pipelineBuilder.UseCitations();
                }
                else if (extension == "Custom Containers".ToUpper())
                {
                    usedExtensions.Add("Custom Containers");
                    pipelineBuilder = pipelineBuilder.UseCustomContainers();
                }
                else if (extension == "Figures".ToUpper())
                {
                    usedExtensions.Add("Figures");
                    pipelineBuilder = pipelineBuilder.UseFigures();
                }
                else if (extension == "Footers".ToUpper())
                {
                    usedExtensions.Add("Footers");
                    pipelineBuilder = pipelineBuilder.UseFooters();
                }
                else if (extension == "Mathematics".ToUpper())
                {
                    usedExtensions.Add("Mathematics");
                    pipelineBuilder = pipelineBuilder.UseMathematics();
                }
                else if (extension == "Hardline Breaks".ToUpper())
                {
                    usedExtensions.Add("Hardline Breaks");
                    pipelineBuilder = pipelineBuilder.UseSoftlineBreakAsHardlineBreak();
                }
                else if (extension == "Emoji".ToUpper())
                {
                    usedExtensions.Add("Emoji");
                    pipelineBuilder = pipelineBuilder.UseEmojiAndSmiley();
                }
                else if (extension == "Smarty Pants".ToUpper())
                {
                    usedExtensions.Add("Smarty Pants");
                    pipelineBuilder = pipelineBuilder.UseSmartyPants();
                }
                else if (extension == "Diagrams".ToUpper())
                {
                    usedExtensions.Add("Diagrams");
                    pipelineBuilder = pipelineBuilder.UseDiagrams();
                }
                else if (extension == "YAML Frontmatter".ToUpper())
                {
                    usedExtensions.Add("YAML Frontmatter");
                    pipelineBuilder = pipelineBuilder.UseYamlFrontMatter();
                }
                else
                {
                    logMessage += string.Format("Unable to use unknown extension '{0}'\n", markdownExtensions[upperExtensions.IndexOf(extension)]);
                }
            }

            logMessage += string.Format("Using markdown extensions: {0}\n", string.Join(", ", usedExtensions.ToArray()));

            var pipeline = pipelineBuilder.Build();

            logMessage += string.Format("Processing {0} files\n", files.Length);

            foreach (var file in files)
            {
                var baseName = file.Substring(sourceDirectory.Length + 1);
                baseName = baseName.Substring(0, baseName.LastIndexOf(".")).Replace("\\", "/");

                try
                {
                    var inReader = new StreamReader(file);
                    var content = inReader.ReadToEnd();
                    var title = "";
                    var themeName = defaultTheme;

                    inReader.Close();

                    foreach(Match match in themeRegex.Matches(content))
                    {
                        if (match.Groups.Count == 2 && (match.Groups[0].Index == 0 || content[match.Groups[0].Index - 1] == '\n'))
                        {
                            themeName = match.Groups[1].Value;
                            content = content.Replace(match.Groups[0].Value, "");
                        }
                    }

                    foreach (Match match in categoriesRegex.Matches(content))
                    {
                        if (match.Groups.Count == 2 && (match.Groups[0].Index == 0 || content[match.Groups[0].Index - 1] == '\n'))
                        {
                            var categoriesString = match.Groups[1].Value;
                            var categoryBits = categoriesString.Split(",".ToCharArray()).Select(x => x.Trim()).ToArray();

                            foreach (var categoryName in categoryBits)
                            {
                                if (!categoriesDictionary.ContainsKey(categoryName))
                                {
                                    categoriesDictionary.Add(categoryName, new List<string>());
                                }

                                if (!categoriesDictionary[categoryName].Contains(baseName))
                                {
                                    categoriesDictionary[categoryName].Add(baseName);
                                }
                            }

                            content = content.Replace(match.Groups[0].Value, "");
                        }
                    }

                    foreach (Match match in titleRegex.Matches(content))
                    {
                        if (match.Groups.Count == 2 && (match.Groups[0].Index == 0 || content[match.Groups[0].Index - 1] == '\n'))
                        {
                            title = match.Groups[1].Value;
                            content = content.Replace(match.Groups[0].Value, "");
                        }
                    }

                    var isCategoryPage = SaneFileName(baseName).StartsWith(SaneFileName(categoryPrefix));

                    if(isCategoryPage && title.Length == 0)
                    {
                        title = baseName.Replace(SaneFileName(categoryPrefix), categoryPrefix);
                    }

                    var fileInfo = new FileInfo()
                    {
                        pageTitle = title.Length > 0 ? title : baseName,
                        baseName = baseName,
                        saneBaseName = SaneFileName(baseName),
                        text = content,
                        theme = themeName.ToLowerInvariant(),
                    };

                    fileCache.Add(baseName, fileInfo);
                }
                catch (Exception e)
                {
                    logMessage += string.Format(" ...   Failed to preprocess file '{0}': {1}\n", file, e.Message);

                    continue;
                }
            }

            var searchNames = new List<string>();
            var searchURLs = new List<string>();

            foreach (var pair in fileCache)
            {
                searchNames.Add(pair.Value.pageTitle);
                searchURLs.Add(SaneFileName(pair.Value.baseName));
            }

            foreach (var categoryName in categoriesDictionary.Keys)
            {
                var formattedCategoryName = FormattedCategoryName(categoryName);
                var saneCategoryName = SaneFileName(formattedCategoryName);

                //Make sure category lists are created
                if (!fileCache.Where(x => x.Value.saneBaseName == SaneFileName(formattedCategoryName)).Any())
                {
                    fileCache.Add(formattedCategoryName, new FileInfo()
                    {
                        pageTitle = formattedCategoryName,
                        baseName = formattedCategoryName,
                        saneBaseName = saneCategoryName,
                        text = "",
                        theme = defaultTheme.ToLowerInvariant(),
                    });

                    searchNames.Add(formattedCategoryName);
                    searchURLs.Add(saneCategoryName);
                }
            }

            if (categoriesDictionary.Count > 0 && !fileCache.ContainsKey(categoryListBaseName))
            {
                var fileInfo = new FileInfo()
                {
                    pageTitle = "Category List",
                    baseName = categoryListBaseName,
                    saneBaseName = categoryListBaseName,
                    text = "",
                    theme = defaultTheme.ToLowerInvariant(),
                };

                fileCache.Add(categoryListBaseName, fileInfo);
            }

            foreach (var file in fileCache.Keys)
            {
                var baseName = file;
                var fileName = Path.GetFileName(baseName);
                var directoryName = Path.GetDirectoryName(baseName);
                var saneBaseName = SaneFileName(baseName);
                var themeName = fileCache[file].theme ?? defaultTheme;

                if(!themesDictionary.ContainsKey(themeName))
                {
                    continue;
                }

                var themeText = themesDictionary[themeName];
                var pageExtension = Path.GetExtension(themes.FirstOrDefault(x => x.Key.ToLowerInvariant() == themeName).Value);
                var outName = Path.Combine(destinationDirectory, SaneFileName(baseName) + pageExtension);

                logMessage += string.Format("... {0} (as {1})\n", file, outName);

                var categoryInfo = new List<KeyValuePair<string, string>>();
                var isCategoryPage = saneBaseName.StartsWith(SaneFileName(categoryPrefix));
                var isCategoryList = saneBaseName == categoryListBaseName;

                //If we're a category page and our base name doesn't match, then that means we're a generated category page.
                //If there is another file whose baseName is equal to our sane base name, then there exists a page that should override the generated one. Skip this one.
                if (isCategoryPage && baseName != saneBaseName && fileCache.Where(x => x.Value.baseName == saneBaseName).Any())
                {
                    continue;
                }

                if(isCategoryPage)
                {
                    var unformattedCategoryName = saneBaseName.Replace(SaneFileName(categoryPrefix), "");
                    var targetKey = unformattedCategoryName;

                    //Might have a regular category string, so try to use that if the categories dictionary doesn't have that.
                    if(!categoriesDictionary.ContainsKey(targetKey))
                    {
                        targetKey = MarkdownStrippedString(unformattedCategoryName, pipeline);
                    }

                    if (targetKey != null && categoriesDictionary.ContainsKey(targetKey))
                    {
                        var items = categoriesDictionary[targetKey];

                        foreach(var item in items)
                        {
                            var cacheInfo = fileCache.Where(x => x.Value.saneBaseName == SaneFileName(item)).Select(x => x.Value).FirstOrDefault();
                            var itemTitle = cacheInfo?.pageTitle;

                            if(itemTitle != null && itemTitle != cacheInfo.saneBaseName && itemTitle != cacheInfo.baseName)
                            {
                                categoryInfo.Add(new KeyValuePair<string, string>(itemTitle, SaneFileName(item)));
                            }
                            else
                            {
                                var lastPiece = item.Replace("\\", "/").Split("/".ToCharArray()).Last().Replace("_", " ");

                                categoryInfo.Add(new KeyValuePair<string, string>(lastPiece, SaneFileName(item)));
                            }
                        }
                    }
                }
                else if(isCategoryList)
                {
                    foreach(var pair in categoriesDictionary)
                    {
                        categoryInfo.Add(new KeyValuePair<string, string>(pair.Key, FormattedCategoryName(pair.Key)));
                    }
                }
                else
                {
                    foreach (var pair in categoriesDictionary)
                    {
                        if (pair.Value.Contains(baseName))
                        {
                            categoryInfo.Add(new KeyValuePair<string, string>(pair.Key, FormattedCategoryName(pair.Key)));
                        }
                    }
                }

                categoryInfo.Sort((a, b) => a.Key.CompareTo(b.Key));

                var fileInfo = fileCache[baseName];
                var processedText = ProcessFile(baseName, fileInfo.text, (string)themeText.Clone(), string.Format("{0}: {1}", baseTitle, fileInfo.pageTitle),
                    fileInfo.pageTitle, navigationInfo, searchNames.ToArray(), searchURLs.ToArray(), categoryInfo, sourceDirectory, directoryName,
                    pageExtension, isCategoryPage || isCategoryList, disableAutoPageExtension, disableLinkCorrection, navigationContent, pipeline);

                try
                {
                    if (directoryName.Length > 0)
                    {
                        var combinedPath = Path.Combine(destinationDirectory, directoryName);

                        if (!Directory.Exists(combinedPath))
                        {
                            Directory.CreateDirectory(combinedPath);
                        }
                    }

                    var outWriter = new StreamWriter(outName);
                    outWriter.Write(processedText);
                    outWriter.Flush();
                    outWriter.Close();
                }
                catch (Exception e)
                {
                    logMessage += string.Format("...   Failed to output file '{0}': {1}\n", file, e.Message);
                }
            }

            logMessage += string.Format("Copying content files (Extensions are '{0}')\n", string.Join(", ", contentExtensions.Select(x => string.Format(".{0}", x)).ToArray()));

            var contentFiles = new string[0];

            try
            {
                contentFiles = Directory.GetFiles(sourceDirectory, "*.*", SearchOption.AllDirectories).Where(x => contentExtensions.Where(y => x.EndsWith(string.Format(".{0}", y))).Any()).ToArray();
            }
            catch (Exception)
            {
                logMessage += string.Format("StaticWiki failed to find content files at the directory '{0}'. This is not important and will simply be ignored.\n", sourceDirectory);
            }

            foreach (var file in contentFiles)
            {
                var baseName = file.Substring(sourceDirectory.Length + 1);
                var directoryName = Path.GetDirectoryName(baseName);
                var from = Path.Combine(sourceDirectory, baseName);
                var to = Path.Combine(destinationDirectory, baseName);

                logMessage += string.Format("... {0} (as '{1}')\n", baseName, to);

                try
                {
                    if (directoryName.Length > 0)
                    {
                        var combinedPath = Path.Combine(destinationDirectory, directoryName);

                        if (!Directory.Exists(combinedPath))
                        {
                            Directory.CreateDirectory(combinedPath);
                        }
                    }

                    File.Copy(from, to, true);
                }
                catch (Exception e)
                {
                    logMessage += string.Format("Unable to copy content file '{0}' (as '{1}'): {2}\n", from, to, e.Message);
                }
            }

            logMessage += "Done\n";

            return true;
        }

        /// <summary>
        /// Gets details on a workspace from a workspace directory by parsing the "staticwiki.ini" file
        /// </summary>
        /// <param name="workspaceDirectory">The workspace's directory</param>
        /// <param name="sourceDirectory">The parsed source directory</param>
        /// <param name="destinationDirectory">The parsed destination directory</param>
        /// <param name="defaultThemeName">The parsed default theme name</param>
        /// <param name="themes">The parsed list of all themes in a format of name to filename</param>
        /// <param name="titleName">The parsed wiki title name</param>
        /// <param name="navigationFileName">The parsed navigation file name</param>
        /// <param name="contentExtensions">The parsed content extensions</param>
        /// <param name="disableAutoPageExtension">Disables automatically adding page extensions to page links</param>
        /// <param name="disableLinkCorrection">Disables automatically replacing invalid links with "#"</param>
        /// <param name="markdownExtensions">Markdown extensions used by the workspace</param>
        /// <param name="logMessage">Our current log mesasge</param>
        /// <returns>Whether we successfully parsed the staticwiki.ini file</returns>
        public static bool GetWorkspaceDetails(string workspaceDirectory, ref string sourceDirectory, ref string destinationDirectory, ref string defaultThemeName, ref KeyValuePair<string, string>[] themes,
            ref string titleName, ref string navigationFileName, ref string[] contentExtensions, ref bool disableAutoPageExtension,
            ref bool disableLinkCorrection, ref string[] markdownExtensions, ref string logMessage)
        {
            try
            {
                var configPath = Path.Combine(workspaceDirectory, configurationFileName);
                var iniParser = new Ini(configPath);

                if (iniParser.GetSections().Length == 0)
                {
                    throw new Exception(string.Format("Unable to open '{0}'\n", configPath));
                }

                sourceDirectory = iniParser.GetValue(configurationSourceDirectoryName, configurationSectionName);
                destinationDirectory = iniParser.GetValue(configurationOutputDirectoryName, configurationSectionName);
                titleName = iniParser.GetValue(configurationTitleName, configurationSectionName);
                defaultThemeName = iniParser.GetValue(configurationDefaultThemeName, configurationSectionName);
                themes = iniParser.GetValue(configurationThemes, configurationSectionName).Split(",".ToCharArray()).Select(x => {
                        var pairs = x.Trim().Split(":".ToCharArray());

                        if(pairs.Length != 2)
                        {
                            return null;
                        }

                        return pairs;
                    })
                    .Where(x => x != null)
                    .Select(x => new KeyValuePair<string, string>(x[0], Path.Combine(workspaceDirectory, x[1])))
                    .ToArray();

                var contentExtensionsString = iniParser.GetValue(configurationContentExtensionsName, configurationSectionName);

                if (contentExtensionsString.Length > 0)
                {
                    contentExtensions = contentExtensionsString.Split(",".ToCharArray()).Select(x => x.Trim()).ToArray();
                }

                var disableAutoPageExtensionString = iniParser.GetValue(configurationDisableAutoPageExtensionsName, configurationSectionName);

                if(disableAutoPageExtensionString == "0")
                {
                    disableAutoPageExtension = false;
                }
                else if(disableAutoPageExtensionString == "1")
                {
                    disableAutoPageExtension = true;
                }

                var disableLinkCorrectionString = iniParser.GetValue(configurationDisableLinkCorrectionName, configurationSectionName);

                if (disableLinkCorrectionString == "0")
                {
                    disableLinkCorrection = false;
                }
                else if (disableLinkCorrectionString == "1")
                {
                    disableLinkCorrection = true;
                }

                markdownExtensions = iniParser.GetValue(configurationMarkdownExtensionsName, configurationSectionName)
                    .Split(",".ToCharArray())
                    .Select(x => x.Trim())
                    .Where(x => x.Length > 0)
                    .ToArray();
            }
            catch (Exception exception)
            {
                logMessage += string.Format("Unable to load project due to exception: {0}\n", exception);

                return false;
            }

            sourceDirectory = Path.Combine(workspaceDirectory, sourceDirectory);
            destinationDirectory = Path.Combine(workspaceDirectory, destinationDirectory);
            navigationFileName = Path.Combine(workspaceDirectory, navigationNameMarkdown);

            if(!File.Exists(navigationFileName))
            {
                navigationFileName = Path.Combine(workspaceDirectory, navigationName);
            }

            try
            {
                if (!Directory.Exists(destinationDirectory))
                {
                    Directory.CreateDirectory(destinationDirectory);
                }
            }
            catch (Exception)
            {
            }

            if (!Directory.Exists(sourceDirectory) || themes.Any(x => !File.Exists(x.Value)))
            {
                logMessage += string.Format("Unable to load project due to invalid required files or directories\n");

                return false;
            }

            return true;
        }
    }
}
